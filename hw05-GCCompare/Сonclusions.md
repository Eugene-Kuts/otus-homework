# Преамбула: 
# очевидно, что наиболее подходяищим GC для условий (см. ниже) будет тот GC, который обеспечит 
# наболее продолжительную работу приложения (пока оно не свалится в OutOfMemory) при минимальном затраченном 
# времени на свою работу, а так же при минимальном количестве сборок.

#АНАЛИЗ ДАННЫХ ПО КАЖДОМУ GC (сами данные находятся в .\data\collected_data.txt):
#   1) UseConcMarkSweepGC обеспечил продолжительное время работы приложения (396420 ms), 
#       но затратил самое большое время на свою работу (45981 ms) и совершил самое большое кол-во сборок (91).
#       Данный GC не самый лучший выбор для условий (см. ниже);
#   2) UseSerialGC обеспечил продолжительное время (сравнимое с UseConcMarkSweepGC) работы приложения (396005 ms), 
#       но затратил значительное время на свою работу (5156 ms), зато совершил не большое кол-во сборок (12).
#       Данный GC больше подходит для условий (см. ниже), нежели UseConcMarkSweepGC, но не является самым лучшим;
#   3) UseG1GC обеспечил наименьшую пордолжительность работы приложения (307927 ms), совершил значительное колчество сборок (26), 
#       но затратил наименьшее время на свою работу (669 ms).
#   4) UseParallelGC обеспечил нормальную пордолжительность работы приложения (372395 ms), совершил малое колчество сборок (12),
#       и затратил приемлемое время на свою работу (1271 ms).
#
# ВЫВОДЫ: 
# Для условий ниже (именно это важно!) я бы предпочел выбрать UseParallelGC, 
# т.к. им обеспечивается продолжительная работа приложения при приемлемом времени работы самого GC 
# и минимальном колчестве сборок.
# НО! Нельзя сказать, что какой-то GC лучше или хуже, т.к. его выбор сильно зависит от внешних условий (см. пример условий ниже). 
#
#
#УСЛОВИЯ:
#   1) данное конкретное приложение - GCCompare.main();
#   2) конфигурация VM (Xms, Xmx, etc.)
#   3) физические характеристики стенда: 
#        а) CPU (частота, количество ядер, кэш и т.д.);
#        б) объем, тип и скорость оперативной памяти;
#        в) пропусная способность шины между CPU и памятью.



  
